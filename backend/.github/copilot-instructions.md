# Инструкция для нейроагента (SCADA Mobile Backend)

Эта инструкция читается **каждый раз** перед выполнением любой задачи в этом репозитории. Она задаёт контекст системы,
её инварианты, правила безопасности и архитектурные ограничения. **Безопасность и архитектурная грамотность —
обязательны, не опциональны.**

## 1) Что это за система

Это Spring Boot backend, который работает как **прослойка между клиентом и внешним сервисом PrintSrv (MarkPrintServer)
**.

- Клиент общается с backend по HTTP.
- Backend общается с PrintSrv по TCP-сокету с собственным бинарным фреймингом и JSON payload.
- У PrintSrv реально доступны только **2 команды**: **QueryAll** (получить полный снимок) и **SetUnitVars** (установить
  значения тегов одного unit).

Система реализует архитектуру **write-through cache + scan cycle**:

1) Клиентские запросы на запись **не пишут в PrintSrv синхронно**. Они кладутся в **буфер pending-команд**.
2) Отдельный автономный цикл (scheduler) примерно раз в `printsrv.polling.fixed-delay-ms` (по умолчанию 5 секунд)
   делает:
    - READ: QueryAll → получить актуальные данные из PrintSrv;
    - BUSINESS LOGIC: забрать и очистить pending буфер;
    - WRITE: выполнить SetUnitVars для pending-команд;
    - UPDATE: обновить in-memory snapshot состоянием из READ.

Клиенты читают состояние только из **snapshot**. Изменения после POST станут видны в GET после следующего scan cycle (
eventual consistency).

## 2) Главные артефакты и «точки истины» в коде

Ориентиры (важное):

- REST API
    - `api/controller/CommandsController` — endpoints:
        - `GET /api/v1/commands/queryAll` — отдаёт snapshot.
        - `POST /api/v1/commands/setUnitVars?unit=&value=` — кладёт команду в буфер.
        - health endpoints: `/health/live`, `/health/ready`.
    - `services/CommandsService` — адаптер API → application.
    - `api/ApiMapper` — преобразование domain → API DTO.

- Application слой
    - `application/ScadaApplicationService` — координация: читает snapshot из store и кладёт команды в буфер.

- Scan Cycle
    - `services/polling/PrintSrvPollingScheduler` — единый цикл READ → LOGIC → WRITE → UPDATE.
    - `services/polling/ScadaCommandExecutor` — выполнение QueryAll/SetUnitVars, маппинг PrintSrv DTO ↔ domain.
    - `services/polling/PrintSrvConnectionManager` — retry/reconnect/recovery state machine вокруг socket-операций.

- Store
    - `store/PrintSrvSnapshotStore` — in-memory snapshot (AtomicReference), без истории.
    - `store/PendingCommandsBuffer` — in-memory буфер pending-команд (ConcurrentHashMap), ограничение размера,
      Last-Write-Wins.

- Интеграция с PrintSrv
    - `printsrv/client/*` — сокет/транспорт/команды/фрейминг.
    - `printsrv/PrintSrvMapper` — PrintSrv DTO → domain.
    - Документация протокола: `PRINTSERV_API.md`.

## 3) Жёсткие инварианты архитектуры (нельзя ломать)

### 3.1. Инварианты Write-Through Cache

- **GET всегда читает только snapshot**, НЕ ходит напрямую в PrintSrv.
- **POST записи всегда быстрый** и не блокируется на PrintSrv: максимум «приняли команду».
- Snapshot — **единственный источник правды** для клиентов; даже если записи не применились, клиенты увидят то, что
  реально пришло из PrintSrv.

### 3.2. Инварианты Scan Cycle (PLC-паттерн)

- Цикл должен быть **последовательным**: READ → LOGIC → WRITE → UPDATE.
- Внутри одного цикла избегай параллелизма и гонок: **один поток — один цикл**.
- UPDATE snapshot выполняется **на основе данных из READ** (QueryAll), а не из ответа SetUnitVars (ответ частичный).

### 3.3. Инварианты буфера pending-команд

- Буфер — `Map<unitNumber, WriteCommand>` с **Last-Write-Wins** для одного unit.
- Буфер **thread-safe** между REST потоками и scheduler.
- Есть **лимит размера** (защита от утечек памяти при долгой недоступности PrintSrv). Переполнение — управляемая
  ошибка (`BufferOverflowException`).

### 3.4. Инварианты integration с PrintSrv

- PrintSrv поддерживает **только QueryAll и SetUnitVars**. Любые другие команды нельзя «добавлять».
- `SetUnitVars` работает **только для одного unit за запрос** (так реализовано и так ожидается).
- Протокол/кодировки нельзя ломать:
    - TCP framing: MAGIC `P001` + 4 байта длины (Big Endian) + JSON.
    - Кодировка JSON: **windows-1251**, не UTF-8.
    - Нумерация unit: в запросах SetUnitVars `Unit` = **число 1-based**, в ответах QueryAll unit’ы в виде ключей `"u1"`,
      `"u2"`.

## 4) Контракты поведения (что клиенту гарантируется)

- `GET /queryAll`:
    - Возвращает snapshot, если он уже есть.
    - Если snapshot ещё не получен (первый запуск) — система может вернуть ошибку готовности (готовность определяется
      наличием snapshot).
    - При проблемах PrintSrv snapshot может быть устаревшим, но остаётся доступным (graceful degradation).

- `POST /setUnitVars`:
    - Возвращает подтверждение приёма (ack).
    - Не гарантирует, что PrintSrv реально применил запись (eventual consistency).
    - Команды могут **потеряться**, если WRITE упал внутри цикла после `getAndClear()` (это текущее поведение
      архитектуры). Не «чинить» это случайными правками — только отдельным архитектурным решением.

## 5) Правила безопасности (обязательные)

### 5.1. Входной HTTP слой

- Валидируй входные параметры: диапазоны unit/value, обязательность, типы. Не доверяй клиенту.
- Не допускай DoS через большие запросы/частоту:
    - помни про лимит буфера;
    - любые тяжёлые операции — только в scan cycle.
- Не логируй лишнее:
    - не печатай в логи чувствительные данные/полный snapshot на уровне INFO;
    - избегай логов, которые могут раздувать файл на каждом цикле.

### 5.2. Сокет и протокол PrintSrv

- Любая работа с сокетом только через существующие компоненты (`SocketManager`, `PrintSrvConnectionManager`).
- Таймауты должны быть настроены и не равны «вечности».
- Нельзя допускать бесконтрольных ретраев без backoff — иначе риск перегрузки сети/сервиса.

### 5.3. Ошибки и устойчивость

- Ошибки PrintSrv — ожидаемая реальность. Система обязана деградировать предсказуемо:
    - snapshot остаётся последним валидным;
    - scheduler не должен падать навсегда.
- В recovery mode операции могут пропускаться (это нормально). Не превращай это в «вечный ERROR-спам».

### 5.4. Конкурентность

- Не добавляй небезопасные синглтоны/статические мутабельные поля.
- Любые разделяемые структуры должны быть потокобезопасными и иметь ясные инварианты.

## 6) Архитектурные правила изменений (как вносить правки правильно)

### 6.1. Слои и зависимости

Держи направление зависимостей:

- API слой зависит от application и мапперов.
- Application зависит от store и domain.
- Polling/Executor зависит от integration (PrintSrv client) и domain/store.
- Domain не зависит от Spring/DTO/сокета.

Если задача требует новую функциональность:

1) Сначала зафиксируй, в каком слое она должна жить.
2) Обнови контракт (DTO/эндпоинт) минимально.
3) Протокол PrintSrv не трогай без крайней причины и без обновления документации.

### 6.2. Изменения поведения — только с явным обсуждением инвариантов

Перед тем как менять:

- семантику буфера (очередь vs map, гарантии доставки),
- правила retry,
- периодичность цикла,
- источник snapshot,
  обязательно сформулируй:
- какие инварианты сохраняются,
- какие новые гарантии появляются,
- какие риски (потеря команд, дубли, идемпотентность) и как они закрываются.

### 6.3. Набор «типовых» задач и куда смотреть

- Новый endpoint/изменение API: `CommandsController`, DTO в `api/dto`, `CommandsService`, `ApiMapper`.
- Изменение scan cycle: `PrintSrvPollingScheduler` и/или `ScadaCommandExecutor`.
- Retry/устойчивость: `PrintSrvConnectionManager` + документация retry.
- Протокол PrintSrv/кодировки/фрейминг: `printsrv/client/*` + `PRINTSERV_API.md`.
- Буфер/снапшот: `store/*`.

## 7) Чеклист перед завершением любой задачи

1) **Архитектурная проверка**:
    - не сломан ли принцип snapshot-only для чтения;
    - не появился ли синхронный сетевой вызов в REST обработчике;
    - не нарушены ли инварианты буфера и scan cycle.

2) **Безопасность**:
    - валидация входа и ограничения;
    - нет ли утечек данных в логах;
    - нет ли бесконечных ретраев/блокировок.

3) **Качество**:
    - минимальные тесты на изменённую логику (буфер/мапперы/сервис);
    - проект собирается.

## 8) Что делать, если запрос пользователя недостаточно точный

- Сделай 1–2 разумных предположения, но **явно перечисли их** прежде чем внедрять изменения.
- Если предположения рискованные (например, гарантии доставки команд), остановись и запроси уточнение.

## 9) Запрещённые классы решений

- «Быстрые фиксы», которые пишут напрямую в PrintSrv из REST endpoint.
- Изменение протокола/кодировки без синхронизации с `PRINTSERV_API.md`.
- Добавление новых PrintSrv-команд «потому что удобно».
- Снятие лимита буфера без альтернативной защиты от DoS.

