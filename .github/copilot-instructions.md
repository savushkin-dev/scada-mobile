
# Инструкции для нейроагента (SCADA Mobile)

## Контекст и цель продукта

Проект предназначен для реального продакшена: автоматизация оперативного оповещения работников большого молочного предприятия о простоях/ЧП на линиях и установках.

Проблема, которую решаем: при остановке участка производственной цепочки сотрудники в других цехах часто не понимают причину (например, закончились заготовки/материалы, оператор отвлёкся, узел стоит), из‑за чего «эффект домино» приводит к остановке упаковки, палетирования, отгрузки и т.п. Приложение должно быстро донести всем заинтересованным сотрудникам, что произошло и почему конвейер/участок стоит.

Ключевая идея: оборудование/периферия отдаёт сигнал, он считывается PrintSrv, дальше бэкенд на Spring агрегирует/нормализует события и рассылает уведомления пользователям.

## Состав системы (высокоуровнево)

В репозитории живут три части:

1) Backend (Spring / Java)

- принимает данные от PrintSrv (или интеграционного слоя), хранит/обрабатывает доменные события, определяет «что случилось» и «кого уведомить».
- предоставляет API для фронтенда.
- отвечает за надёжность: повторные попытки, идемпотентность, устойчивость к временным сбоям.

1) Frontend (планируется): React + Vite + TypeScript

- web‑клиент, основной UI для сотрудников.
- работает с backend API.
- должен быть простым, быстрым, понятным «в полях».

1) Android (обёртка сайта): Bubblewrap (TWA) + Gradle

- Android‑приложение — это обёртка веб‑клиента.
- основной UX и логика остаются в вебе; Android слой минимален и служит упаковкой/доставкой.

В дальнейшем планируется контейнеризация (Docker) и оркестрация (Kubernetes) с развёртыванием в инфраструктуре компании и работой по внутренней сети.

## Общий поток данных и взаимодействие компонентов

Ориентируйся на следующий общий пайплайн (без углубления в детали конкретных модулей):

1) Событие на оборудовании

- на установке/аппарате происходит событие (ошибка, стоп, отсутствие расходника, состояние «ждём» и т.п.).

1) Считывание через PrintSrv

- PrintSrv выступает источником/посредником, который считывает сигнал/значение и передаёт его дальше.

1) Вход в backend (Spring)

- backend принимает входящее сообщение/сигнал, валидирует, приводит к доменной модели «событие/инцидент».
- backend определяет тип инцидента, причину (если известна), приоритет/критичность, и целевую аудиторию.

1) Уведомления и отображение

- backend инициирует доставку уведомлений (механизм зависит от реализации проекта: важно лишь, что уведомление распространяется на всех нужных сотрудников).
- frontend показывает актуальное состояние/инциденты и даёт сотруднику понять: что произошло, где, почему, что делать дальше.

1) Android‑клиент

- Android‑приложение (Bubblewrap) отображает тот же web‑клиент.

## Как нейроагенту работать с этим репозиторием

Этот файл — общий. Агенту важно сохранять целостность архитектуры и не «переизобретать» продукт.

### Принципы

- Прод‑ориентированность: все изменения должны учитывать реальную эксплуатацию на производстве (нестабильная сеть, множество устройств, важность понятных уведомлений, минимизация ложных тревог).
- Минимальные изменения: делай только то, что просит пользователь, без «улучшений ради улучшений».
- Обратная совместимость: по возможности не ломай существующие контракты backend API и интеграции с PrintSrv.
- Наблюдаемость: логирование/метрики/диагностика важны, но добавлять их нужно точечно и без перегруза.

### Что можно предполагать

- Основной фундамент и ключевой функционал backend уже реализованы.
- Во фронтенде есть рабочий плейсхолдер; следующий крупный этап — полноценная реализация web‑клиента на React + Vite + TypeScript.
- Android часть не должна содержать бизнес‑логики; она следует за веб‑клиентом.

### Как принимать решения при неоднозначности

- Выбирай простейшую интерпретацию, которая соответствует описанной задаче (быстро донести «что/где/почему стоит»).
- Если выбор влияет на контракты (API, формат событий PrintSrv, модель инцидентов) — задай 1–3 уточняющих вопроса вместо угадывания.

### Инварианты домена (на уровне здравого смысла)

- Остановка/инцидент на одном участке влияет на цепочку процессов.
- В уведомлении важны: участок/оборудование, краткая причина, время, статус (активно/исправлено), и понятность для человека.

## Напоминание о будущей инфраструктуре

Даже если сейчас код запускается локально, держи в голове последующее:

- сервисы будут обёрнуты в Docker и развёрнуты в Kubernetes;
- взаимодействие будет идти по сети компании;
- конфигурация должна быть внешней (через env/конфиг), без жёстких привязок к локальной машине.

## Быстрые команды (Makefile)

В корне репозитория есть Makefile с короткими командами для локальной разработки. Агент может использовать их как “официальный” способ запуска.

Общее:

- `make help` — показать все шорткаты и подсказки.

Backend (Spring Boot, готово и используется):

- `make back-run` — запустить backend в текущем терминале.
- `make back-run-bg` — запустить backend в фоне (логи пишутся в файл).
- `make back-status` — проверить, запущен ли backend в фоне.
- `make back-stop` — остановить backend, поднятый через `back-run-bg`.
- `make back-stop-force` — аварийная остановка по порту.
- `make back-build` — собрать backend.
- `make back-test` — запустить тесты backend.
- `make back-clean` — очистить сборку backend.

Примечания:

- Порт по умолчанию: `BACKEND_PORT=8080` (можно переопределить: `make back-run-bg BACKEND_PORT=9090`).
- На Windows фоновые команды используют PowerShell-скрипты из `backend/scripts`, а логи/пид — в `backend/logs`.

Frontend (пока плейсхолдеры — командами можно пользоваться как “точкой правды”, когда фронт начнёт собираться):

- `make front-install` — плейсхолдер для установки зависимостей.
- `make front-dev` — плейсхолдер для dev-сервера.
- `make front-build` — плейсхолдер для production-сборки.

Bubblewrap / Android (пока плейсхолдеры):

- `make bwa-init` — плейсхолдер для `bubblewrap init`.
- `make bwa-build-apk` — плейсхолдер для сборки APK.
